<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">

    <style>
        .flex-container{
        }
        .flex-element{
            border: 1px solid #006644;
            margin: 10px;
            padding: 10px;
        }

    </style>

    <script>
        function setFlexProperties(){

            var flexContainers = document.querySelectorAll('.flex-container');
            var flexPropertiesForm = document.forms.setDisplayPropertiesForm;
            for (var ContainerNum = 0; ContainerNum < flexContainers.length; ContainerNum++) {
                var flexContainer = flexContainers[ContainerNum];
                flexContainer.style.display = flexPropertiesForm.elements.flexDisplay.value;
                flexContainer.style.flexDirection = flexPropertiesForm.elements.flexDirection.value;
                flexContainer.style.flexWrap = flexPropertiesForm.elements.flexWrap.value;
                flexContainer.style.justifyContent = flexPropertiesForm.elements.justifyContent.value;
                flexContainer.style.alignItems = flexPropertiesForm.elements.alignItems.value;
            }
        }

    </script>

    <title>Flex test</title>
</head>
<body>

<form name="setDisplayPropertiesForm">
    <div class="set-flex-display">
        <h4>Установить Flex Display</h4>
        <p><input name="flexDisplay" type="radio" value="flex">display:flex</p>
        <p><input name="flexDisplay" type="radio" value="inline-flex">display:inline-flex</p>
    </div>

    <div class="set-flex-direction">
        <h4>Установить Flex Direction</h4>
        <p><input name="flexDirection" type="radio" value="row">flex-direction:row</p>
        <p><input name="flexDirection" type="radio" value="row-reverse">flex-direction:row-reverse</p>
        <p><input name="flexDirection" type="radio" value="column">flex-direction:column</p>
        <p><input name="flexDirection" type="radio" value="column-reverse">flex-direction:column-reverse</p>
    </div>


    <div class="set-flex-wrap">
        <h4>Установить Flex Wrap</h4>
        <p><input name="flexWrap" type="radio" value="nowrap">flex-wrap:nowrap</p>
        <p><input name="flexWrap" type="radio" value="wrap">flex-wrap:wrap</p>
        <p><input name="flexWrap" type="radio" value="wrap-reverse">flex-wrap:wrap-reverse</p>
    </div>

    <div class="set-justify-content">
        <h4>Установить Justify Content</h4>
        <p><input name="justifyContent" type="radio" value="flex-start">justify-content:flex-start</p>
        <p><input name="justifyContent" type="radio" value="flex-end">justify-content:flex-end</p>
        <p><input name="justifyContent" type="radio" value="center">justify-content:center</p>
        <p><input name="justifyContent" type="radio" value="space-between">justify-content:space-between</p>
        <p><input name="justifyContent" type="radio" value="space-around">justify-content:space-around</p>
    </div>

    <div class="set-align-items">
        <h4>Установить Align Items</h4>
        <p><input name="alignItems" type="radio" value="flex-start">align-items:flex-start</p>
        <p><input name="alignItems" type="radio" value="flex-end">align-items:flex-end</p>
        <p><input name="alignItems" type="radio" value="center">align-items:center</p>
        <p><input name="alignItems" type="radio" value="baseline">align-items:baseline</p>
        <p><input name="alignItems" type="radio" value="stretch">align-items:stretch</p>
    </div>

    <input type="button" onclick="setFlexProperties()" value="Установить">
</form>

<div class="flex-container">
    <div class="flex-element">1</div>
    <div class="flex-element">2</div>
    <div class="flex-element flex-container">
        <div class="flex-element">3</div>
        <div class="flex-element">4</div>
        <div class="flex-element">5</div>
        <div class="flex-element">6</div>
        <div class="flex-element">7</div>
    </div>
    <div class="flex-element">8</div>
    <div class="flex-element">9</div>
    <div class="flex-element">10</div>
</div>

<br><br><br>

<div class="flex-container">
    <div class="flex-element"><a href="https://habrahabr.ru/post/347688/">ссылка на оригинал на хабре</a></div>
    <div class="flex-element">Когда на IT-форумах задают вопрос «Быстрее ли язык программирования X языка Y», это обычно вызывает потоки эмоций и считается некорректным. С родни вопросу про религию или предпочтение той или иной политической партии. Действительно, язык — это способ выражения мысли, идеи. В данном случае идеи программной системы. Он не быстр и не медлен. Он может быть более или менее лаконичным, более или менее точным. А скорость определяется не столько языком, сколько конечным кодом, который генерирует компилятор этого языка. Или скоростью интерпретатора в случае интерпретируемого языка.</div>
     <div class="flex-element flex-container">
        <div class="flex-element">Для того, чтобы чуть более основательно ответить себе на этот вопрос, я решил написать ещё один (да-да, тоже немного синтетический) тест — кодирование данных методом Хаффмана. Навела на мысль статья «Алгоритм Хаффмана на пальцах»</div>
        <div class="flex-element">Сначала я реализовал кодирование на чистом C. Если помните, для его реализации требуется очередь с приоритетом, потому как там для построения дерева кодирования нужно быстро находить символы, упорядоченные по числу их повторений. Алгоритмические подробности я опущу, отсылая читателя по ссылке выше (пардон за тавтологию). Собственно, на этом всё бы и закончилось, и не было бы никакой статьи, потому что кодирование я реализовывал только в качестве тренировки в алгоритмике. Но по ходу работы я заметил, как же быстро компилируется программа на C по сравнению с подобного размера исходниками на C++. И упомянул об этом коллеге по работе. Высказав предположение, что компиляция на C++ включает, наверное, ещё множество способов оптимизации. Так что подобно написанный код на C++, наверное, должен быть быстрее — там же будет работать магия самых-самых гуру в области написания оптимизирующих компиляторов. Ухмыльнувшись, коллега ответил: «Проверь».</div>
        <div class="flex-element">И тогда я переписал кодирование Хаффмана на C++. Для чистоты эксперимента я не менял основополагающих принципов, к примеру, не вставлял пользовательский распределитель памяти. Это можно сделать и в C (более «кастомно») и в C++ (более «нативно»). В чём же тут тогда «C++-ность»?</div>
        <div class="flex-element">Первое, что логично выразить через шаблоны в C++, это очередь с приоритетом. На C она представлена в виде структуры, главный элемент которой — указатель на массив указателей на узлы с данными:</div>
        <div class="flex-element">Узел с данными может быть любым типом, но его первым элементом должна быть следующая структура:</div>
     </div>
    <div class="flex-element">Так как очередь не занимается управлением памятью под сами узлы, ей незачем знать, из чего реально состоит узел. Всё, что требуется для работы, это получить его вес: ((struct priority_queue_node*) node_ptr)→weight. Добавление узла в очередь с учётом возможного перевыделения памяти выглядит несколько громоздко:</div>
    <div class="flex-element">Создание очереди и её удаление с обработкой всех ошибок — тоже много строчек кода по сравнению с C++ версией, что ожидаемо. Собственно, версия очереди на C++ выглядит так (внимание — на представление данных):</div>
    <div class="flex-element">Налицо такое же расположение элементов узла в памяти, как и в C версии — сначала идёт вес, затем полезная нагрузка узла, которая, как будет показано ниже, состоит из целочисленного скаляра — высоты дерева, содержащегося в этом узле, и указателя на корень этого дерева. Сами узлы в этой очереди приоритетов хранятся также — указатель m_nodes указывает на массив указателей на узлы.</div>
 </div>

</body>
</html>
