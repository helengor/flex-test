<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">

    <style>
        .flex-container{
            width: 100%;
            height: 800px;
        }
        .flex-element{
            border: 1px solid #006644;
            margin: 10px;
            padding: 10px;
        }

    </style>

    <script>
        function setFlexProperties(){

            var flexContainer = document.querySelector('.flex-container');
            var flexPropertiesForm = document.forms.setDisplayPropertiesForm;
            flexContainer.style.display = flexPropertiesForm.elements.flexDisplay.value;
            flexContainer.style.flexDirection = flexPropertiesForm.elements.flexDirection.value;
            flexContainer.style.flexWrap = flexPropertiesForm.elements.flexWrap.value;
            flexContainer.style.justifyContent = flexPropertiesForm.elements.justifyContent.value;
            flexContainer.style.alignItems = flexPropertiesForm.elements.alignItems.value;
        }

    </script>

    <title>Flex test</title>
</head>
<body>

<form name="setDisplayPropertiesForm">
    <div class="set-flex-display">
        <h4>Установить Flex Display</h4>
        <p><input name="flexDisplay" type="radio" value="flex">display:flex</p>
        <p><input name="flexDisplay" type="radio" value="inline-flex">display:inline-flex</p>
    </div>

    <div class="set-flex-direction">
        <h4>Установить Flex Direction</h4>
        <p><input name="flexDirection" type="radio" value="row">flex-direction:row</p>
        <p><input name="flexDirection" type="radio" value="row-reverse">flex-direction:row-reverse</p>
        <p><input name="flexDirection" type="radio" value="column">flex-direction:column</p>
        <p><input name="flexDirection" type="radio" value="column-reverse">flex-direction:column-reverse</p>
    </div>


    <div class="set-flex-wrap">
        <h4>Установить Flex Wrap</h4>
        <p><input name="flexWrap" type="radio" value="nowrap">flex-wrap:nowrap</p>
        <p><input name="flexWrap" type="radio" value="wrap">flex-wrap:wrap</p>
        <p><input name="flexWrap" type="radio" value="wrap-reverse">flex-wrap:wrap-reverse</p>
    </div>

    <div class="set-justify-content">
        <h4>Установить Justify Content</h4>
        <p><input name="justifyContent" type="radio" value="flex-start">justify-content:flex-start</p>
        <p><input name="justifyContent" type="radio" value="flex-end">justify-content:flex-end</p>
        <p><input name="justifyContent" type="radio" value="center">justify-content:center</p>
        <p><input name="justifyContent" type="radio" value="space-between">justify-content:space-between</p>
        <p><input name="justifyContent" type="radio" value="space-around">justify-content:space-around</p>
    </div>

    <div class="set-align-items">
        <h4>Установить Align Items</h4>
        <p><input name="alignItems" type="radio" value="flex-start">align-items:flex-start</p>
        <p><input name="alignItems" type="radio" value="flex-end">align-items:flex-end</p>
        <p><input name="alignItems" type="radio" value="center">align-items:center</p>
        <p><input name="alignItems" type="radio" value="baseline">align-items:baseline</p>
        <p><input name="alignItems" type="radio" value="stretch">align-items:stretch</p>
    </div>

    <input type="button" onclick="setFlexProperties()" value="Установить">
</form>

<div class="flex-container">
    <div class="flex-element"><a href="https://habrahabr.ru/post/347688/">ссылка на оригинал на хабре</a></div>
    <div class="flex-element">Когда на IT-форумах задают вопрос «Быстрее ли язык программирования X языка Y», это обычно вызывает потоки эмоций и считается некорректным. С родни вопросу про религию или предпочтение той или иной политической партии. Действительно, язык — это способ выражения мысли, идеи. В данном случае идеи программной системы. Он не быстр и не медлен. Он может быть более или менее лаконичным, более или менее точным. А скорость определяется не столько языком, сколько конечным кодом, который генерирует компилятор этого языка. Или скоростью интерпретатора в случае интерпретируемого языка.</div>
    <div class="flex-element">Но это всё философия. А на практике обычно есть практическая задача разработки ПО. И, действительно, реализовать это ПО можно на десятке разных языков программирования. Поэтому, хоть это и «религиозный вопрос» в случае публичного обсуждения, вопрос этот часто возникает в голове IT-специалиста, стоящего перед конкретной задачей. «Сколько времени мне потребуется для реализации задачи на языке X и какие у полученного ПО будут характеристики, в том числе скоростные. По сравнению с реализацией этой задачи на языке Y». Понятное дело, точного ответа на этот вопрос нет, специалист опирается на свой личный опыт и отвечает как-то типа «с вероятностью 95%, написанная на ассемблере, эта задача будет работать быстрее, чем на php». Но, положа руку на сердце, опыт этот редко базируется на точных цифрах реальных задач, которые сам этот специалист реализовал. Нет, ну кто в здравом уме будет писать сложное ПО сначала на php, а потом его же переписывать на ассемблере, только чтобы измерить характеристики? В основном ограничиваются синтетическими тестами типа сортировки массива, построения и обхода бинарного дерева и тому подобных.</div>
    <div class="flex-element">Я, как специалист, пишущий 90% на C++, часто натыкаюсь на «холливарные» темы сравнения этого языка с другими. И один из них — это прародитель — язык C. На том же quora.com часто поднимают этот вопрос «А быстрее ли язык C языка C++» (что некорректно, как я объяснил выше), или «А почему ядро Linux или тонна GNU утилит пишется на C а не на C++» (что является вполне корректным вопросом). На второй вопрос я для себя ответил так:</div>
    <div class="flex-element">Так как язык C является частью языка C++, мне по ходу моих каждодневных задач приходится решать, выразить ли какую-то часть логики «более в C стиле» (с работой с «сырыми» указателями, очисткой памяти через memset, передачей контекста через void*), или типобезопасно в C++ стиле (указатели обёрнуты в unique_ptr / shared_ptr, память зачищается нормально написанными конструкторами, контекст передаётся как типизированный объект: либо указателем на базовый класс с виртуальными функциями, либо вообще как шаблон).</div>
    <div class="flex-element flex-container">
        <div class="flex-element">Для того, чтобы чуть более основательно ответить себе на этот вопрос, я решил написать ещё один (да-да, тоже немного синтетический) тест — кодирование данных методом Хаффмана. Навела на мысль статья «Алгоритм Хаффмана на пальцах»</div>
        <div class="flex-element">Сначала я реализовал кодирование на чистом C. Если помните, для его реализации требуется очередь с приоритетом, потому как там для построения дерева кодирования нужно быстро находить символы, упорядоченные по числу их повторений. Алгоритмические подробности я опущу, отсылая читателя по ссылке выше (пардон за тавтологию). Собственно, на этом всё бы и закончилось, и не было бы никакой статьи, потому что кодирование я реализовывал только в качестве тренировки в алгоритмике. Но по ходу работы я заметил, как же быстро компилируется программа на C по сравнению с подобного размера исходниками на C++. И упомянул об этом коллеге по работе. Высказав предположение, что компиляция на C++ включает, наверное, ещё множество способов оптимизации. Так что подобно написанный код на C++, наверное, должен быть быстрее — там же будет работать магия самых-самых гуру в области написания оптимизирующих компиляторов. Ухмыльнувшись, коллега ответил: «Проверь».</div>
        <div class="flex-element">И тогда я переписал кодирование Хаффмана на C++. Для чистоты эксперимента я не менял основополагающих принципов, к примеру, не вставлял пользовательский распределитель памяти. Это можно сделать и в C (более «кастомно») и в C++ (более «нативно»). В чём же тут тогда «C++-ность»?</div>
        <div class="flex-element">Первое, что логично выразить через шаблоны в C++, это очередь с приоритетом. На C она представлена в виде структуры, главный элемент которой — указатель на массив указателей на узлы с данными:</div>
        <div class="flex-element">Узел с данными может быть любым типом, но его первым элементом должна быть следующая структура:</div>
    </div>

    <div class="flex-element">Так как очередь не занимается управлением памятью под сами узлы, ей незачем знать, из чего реально состоит узел. Всё, что требуется для работы, это получить его вес: ((struct priority_queue_node*) node_ptr)→weight. Добавление узла в очередь с учётом возможного перевыделения памяти выглядит несколько громоздко:</div>
    <div class="flex-element">Создание очереди и её удаление с обработкой всех ошибок — тоже много строчек кода по сравнению с C++ версией, что ожидаемо. Собственно, версия очереди на C++ выглядит так (внимание — на представление данных):</div>
    <div class="flex-element">Налицо такое же расположение элементов узла в памяти, как и в C версии — сначала идёт вес, затем полезная нагрузка узла, которая, как будет показано ниже, состоит из целочисленного скаляра — высоты дерева, содержащегося в этом узле, и указателя на корень этого дерева. Сами узлы в этой очереди приоритетов хранятся также — указатель m_nodes указывает на массив указателей на узлы.</div>
    <div class="flex-element">Для сравнения — положить новый элемент в очередь теперь выглядит более лаконично и типобезопасно (перевыделение памяти — в отдельном методе increase_capacity, что не меняет сути):</div>
    <div class="flex-element">В очередь впоследствии будут вставляться части дерева символов, которые затем будут объединяться в соответствии с числом повторений каждого символа так, чтобы в конце получить дерево кодирования. На C это дерево представляется простейшими структурами с сырыми указателями, базовая из них содержит идентификатор конечного типа:</div>
    <div class="flex-element">Этот шаг вообще не отличается для C и C++ реализации. Сначала просчитывается число повторений каждого символа во входном блоке данных, и заполняется табличка из 256 байт. Потом в очередь с приоритетом кладутся микро-деревья, состоящие только из одного терминального узла. Далее узлы объединяются путём последовательного извлечения из очереди пары, ближайшей к её вершине, и вставкой туда промежуточного узла, содержащего извлечённые прежде.</div>
    <div class="flex-element">Следующим этапом из дерева кодирования нужно построить таблицу, где каждому символу в соответствие поставлена последовательность бит, отражающих прохождение по, только что построенному, дереву кодирования до этого символа. Код для обхода дерева и «набивания» последовательности бит в обоих версиях практически идентичен. Наибольший интерес же представляет то, как хранить эту последовательность бит и оперировать ею. Ведь после построения этой таблицы начнётся то, ради чего всё затевалось. Проходя по входному буферу для каждого, найденного там символа, будет браться его битовая последовательность и добавляться к результирующей выходной последовательности.</div>
</div>

</body>
</html>
